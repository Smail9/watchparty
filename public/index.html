<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Watch Party</title>
  <style>
    body{font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;margin:0;padding:24px}
    .wrap{max-width:900px;margin:0 auto}
    .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin:12px 0}
    video{width:100%;max-height:70vh;background:#000;border-radius:12px}
    input,button{padding:8px 12px;border:1px solid #ccc;border-radius:10px}
    button{cursor:pointer}
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Watch Party</h1>

    <div class="row">
  <input id="srcInput" type="url" placeholder="https://... .mp4" style="min-width:360px" />
  <button id="setSrcBtn">Définir la vidéo pour tous</button>
</div>


    <video id="player" controls preload="metadata">
      <!-- Si tu veux utiliser la vidéo proxifiée depuis server.js -->
      <source src="/video-remote" type="video/mp4">
    </video>

    <div class="row">
      <input type="file" id="filePicker" accept="video/*" />
      <button id="syncBtn">Me recaler</button>
    </div>
  </div>

  <script>
    // server.js — extrait : état des rooms + applyAction + onmessage

// ... (tes imports/express/proxy identiques)

const wss = new WebSocketServer({ server, path: '/watchparty' });

// === Gestion des salles ===
const rooms = new Map(); // roomId -> { clients:Set<ws>, state:{ playing, time, updatedAt, src } }

function getOrCreateRoom(roomId) {
  if (!rooms.has(roomId)) {
    rooms.set(roomId, {
      clients: new Set(),
      state: { playing: false, time: 0, updatedAt: Date.now(), src: null } // <-- src ajouté
    });
  }
  return rooms.get(roomId);
}

function broadcast(room, payload, except) {
  for (const client of room.clients) {
    if (client !== except && client.readyState === 1) {
      try { client.send(JSON.stringify(payload)); } catch {}
    }
  }
}

function applyAction(room, action) {
  const now = Date.now();

  // <-- NOUVEAU: changer la source commune
  if (action.type === 'setSource') {
    room.state.src = action.src || null;
    room.state.time = 0;
    room.state.playing = false;
    room.state.updatedAt = now;
    return;
  }

  if (action.type === 'seek') {
    room.state.time = action.time || 0;
    room.state.updatedAt = now;
  } else if (action.type === 'play') {
    room.state.playing = true;
    room.state.time = action.time ?? room.state.time;
    room.state.updatedAt = now;
  } else if (action.type === 'pause') {
    room.state.playing = false;
    room.state.time = action.time ?? room.state.time;
    room.state.updatedAt = now;
  }
}

wss.on('connection', (ws, req) => {
  const params = new URLSearchParams(req.url.split('?')[1] || '');
  const roomId = params.get('room') || 'default';
  const room = getOrCreateRoom(roomId);
  room.clients.add(ws);

  // État complet envoyé au nouveau client (inclut src)
  ws.send(JSON.stringify({ type: 'syncState', state: room.state }));

  ws.on('message', raw => {
    let msg; try { msg = JSON.parse(raw); } catch { return; }
    if (['play', 'pause', 'seek', 'setSource'].includes(msg.type)) { // <-- setSource pris en compte
      applyAction(room, msg);
      broadcast(room, msg, ws);
    } else if (msg.type === 'syncRequest') {
      ws.send(JSON.stringify({ type: 'syncState', state: room.state }));
    }
  });

  ws.on('close', () => {
    room.clients.delete(ws);
    if (room.clients.size === 0) {
      setTimeout(() => { if (room.clients.size === 0) rooms.delete(roomId); }, 5 * 60 * 1000);
    }
  });
});


    // Connexion auto à la salle depuis l'URL
    connect(initialRoom);
  </script>
</body>
</html>
